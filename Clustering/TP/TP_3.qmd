---
title: "TP 3 :  Classification non supervisée (Clustering)"
author: "Zaineb Smida"
lang: fr
format:
  pdf:
    embed-resources: true
    self-contained-math: true
    self-contained: true
    code-fold: true
    code-summary: "Show the code"
    number-sections: true
    standalone: true
params:
  solution: false
execute: 
  cache: false
header-includes:
  - \usepackage{graphicx}
  - \usepackage{fancyhdr}
  - |
    % Ajuster la hauteur de l'en-tête
    \addtolength{\headheight}{2.5cm}

    % Appliquer le style fancy pour toutes les pages
    \pagestyle{fancy}

    % Configurer le texte et logo dans l'en-tête
    \fancyhead[L]{\textbf{5GEA - Analyse des données multidimensionnelles}}  % Texte à gauche
    \fancyhead[R]{\includegraphics[height=0.8cm]{logo_INSA.pdf}}  % Logo à droite

    % Ajouter une ligne horizontale sous l'en-tête
    \renewcommand{\headrulewidth}{0.4pt}  % Ligne horizontale sous l'en-tête

    % Appliquer le même en-tête pour la première page
    \fancypagestyle{plain}{
      \fancyhead[L]{\textbf{5GEA - Analyse des données multidimensionnelles}}  % Texte à gauche
      \fancyhead[R]{\includegraphics[height=0.8cm]{logo_INSA.pdf}}  % Logo à droite
      \renewcommand{\headrulewidth}{0.4pt}  % Ligne horizontale sous l'en-tête
    }

    % Ajouter la ligne horizontale et l'email dans le pied de page avec le numéro de page
    \fancyfoot[L]{\href{mailto:zaineb.smida@insa-lyon.fr}{zaineb.smida@insa-lyon.fr}}  % Adresse e-mail à gauche
    \fancyfoot[C]{}  % Désactiver le numéro de page centré
    \fancyfoot[R]{\thepage}  % Numéro de page à droite
    \renewcommand{\footrulewidth}{0.4pt}  % Ligne horizontale dans le pied de page
---
On reprend ici le jeu de données sur les 25 pays de l'Union Européenne (source : Eurostat 2002) qu'on importe de la façon suivante :

```{r}
pays <- read.table("pays_eu.txt", header = T)
row.names(pays) <- pays$PAYS
```

En revanche, on va considérer uniquement les variables suivantes : 

* espérance de vie à la naissance pour un homme (en années)
* espérance de vie à la naissance pour une femme (en années)
* taux d'activité (en pourcentage) : population active/population en âge de travailler
* taux d'inflation (en pourcentage)
* taux d'emploi (en pourcentage) : actifs occupés/population en âge de travailler
* taux de chômage (en pourcentage): chômeurs/population active

On extrait donc les colonnes qui nous intéressent : 

```{r}
paysred <- pays[, c("EVH", "EVF", "TEMP",  "TINF", "TACT", "TCHOM")]
```


Packages nécessaires : 
```{r setup, message=FALSE}
library("FactoMineR")
library("cluster")
```


## Question

Pourquoi faut-il centrer et réduire les variables ?

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
Pour regarder les différences de magnitude entre les variables, on peut utiliser des indicateurs statistiques de base. 
:::

::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On constate que les moyennes sont différentes (voir par par exemple `TINF` et `EVH`) 
```{r include=params$solution}
summary(paysred) # les moyennes sont très différentes 
```
`r if (!params$solution) ":::"` 
:::

## Question

Centrer et réduire les variables

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
On pourra utiliser la fonction `scale()`
:::

::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On créé un nouvel objet qui contient les données centrées et réduites
```{r include=params$solution}
paysred2 <- scale(paysred, center = TRUE, scale = TRUE)
```
`r if (!params$solution) ":::"` 
:::


## Question

On décide tout d'abord de faire une classification par Agrégation autour des Moyennes Mobiles (AMM ou $k$-means en anglais). Représenter le $R^2$ global en fonction du nombre de groupes et justifier ainsi le choix du nombre de groupes. 

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
On utilisera la fonction `kmeans()` en faisant varier le paramètre `centers` pour modifier le nombre de classe. On pourra fixer `nstart` à 100. L'objet retourné contient un certain nombre d'informations sur la classification : par exemple l'inertie inter-classes est donnée dans `$withinss` et l'inertie totale par `$tot.withinss` ce qui permet de calculer le $R^2$
:::

::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On va stocker les valeurs de $R^2$ dans un vecteur pour chaque nombre de classes et on le représente. Ici, on décide de garder $k=4$ classes, ce qui correspond à une rupture de pente à environ $R^2=0.69$. 
```{r include=params$solution, fig.width = 5, fig.height = 3.5}
R2 <- numeric(10)
for(k in 1:10) {
  my_clus <- kmeans(paysred2, k, nstart = 100)
  R2[k] <- my_clus$betweenss/my_clus$totss
}
plot(R2, type = "b", ylim = c(0, 1), xlab = "nombre de classes")
```
`r if (!params$solution) ":::"` 
:::



## Question

Confirmer votre choix avec le calcul du coefficient silhouette moyen que vous représenterez graphiquement en fonction du nombre de groupes.

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
On utilisera la fonction `avg_sil()` suivante qui fait appel au package **cluster**
```{r}
library(cluster) #pour avoir la fonction silhouette
avg_sil <- function(k) {
  km.res = kmeans(paysred2, centers = k, nstart = 100)
  ss = silhouette(km.res$cluster, dist(paysred2))
  mean(ss[, 3])
}
```
:::

::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
Le choix de 4 classes est justifié
```{r include=params$solution}
avg_sil_values = sapply(2:10, avg_sil)
plot(2:10, avg_sil_values,
     type = "b", pch = 19,
     xlab = "Number of clusters K",
     ylab = "Average Silhouettes")
#coroborre le choix k=4
```
`r if (!params$solution) ":::"` 
:::



## Question

On choisit ainsi de garder 4 classes. Ajouter une variable dans le jeu de données qui donne le numéro de la classe obtenue avec la fonction `kmeans()`. On utilisera la classe `factor` pour caractériser les classes. Donner les effectifs des classes trouvées. 

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
On peut récupérer les numéros des classes à partir de la syntaxe `$cluster`; on peut créer un `factor` avec la fonction `factor()`. 
:::

::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 

* Le 1er cluster est le plus gros avec 11 observations (Rep-tche, Danemark, Allemagne, Irlande, Chypre, Pays-Bas, Autriche, Portugal, Finlande, Suede, Royaume-Uni), 
* le 2eme groupe contient 7 observations (Belgique, Grece, Espagne,  France, Italie, Luxembourg, Malte), 
* le 3eme groupe contient 5 observations (Estonie, Lettonie, Lituanie, Pologne, Slovaquie), 
* le plus petit groupe contient uniquement 2 observations (Hongrie et Slovénie). 

```{r include=params$solution}
set.seed(4)
resuclassif <- kmeans(paysred2, 4, nstart = 100)
paysred$my_cluster <- as.factor(resuclassif$cluster)
table(paysred$my_cluster)
```
`r if (!params$solution) ":::"` 
:::


## Question

Faire les boîtes à moustaches des variables par groupe. Calculer les moyennes des variables à l'intérieur de chaque groupe. Calculer le rapport de corrélation pour chaque variable et les classer par ordre d'importance. Représenter le nuage de points des deux variables les plus importantes dans lesquel vous représenterez les observations avec des couleurs différentes selon leur groupe d'appartenance. Vous représenterez aussi les barycentres des classes. 

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
Pour calculer les moyennes par classe, on pourra utiliser la fonction `tapply()` (voir notes de cours). 
:::

::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On représente les boîtes à moustaches :
```{r include=params$solution, fig.width = 6, fig.height = 3.5}
par(mfrow = c(2, 3), mar = c(3, 3, 0.25, 0.25))
boxplot(EVH ~ my_cluster, data = paysred)
title(main = "EVH", line = -1)
boxplot(EVF ~ my_cluster, data = paysred)
title(main = "EVF", line = -1)
boxplot(TEMP ~ my_cluster, data = paysred)
title(main = "TEMP", line = -1)
boxplot(TINF ~ my_cluster, data = paysred)
title(main = "TINF", line = -1)
boxplot(TACT ~ my_cluster, data = paysred)
title(main = "TACT", line = -1)
boxplot(TCHOM ~ my_cluster, data = paysred)
title(main = "TCHOM", line = -1)
```
On calcule les moyennes par groupe : 
```{r include=params$solution}
paysred$my_cluster <- factor(paste0("G", resuclassif$cluster))
my_mean <- data.frame(
  EVH = tapply(paysred$EVH, paysred$my_cluster, mean), 
  EVF = tapply(paysred$EVF, paysred$my_cluster, mean), 
  TEMP = tapply(paysred$TEMP, paysred$my_cluster, mean), 
  TINF = tapply(paysred$TINF, paysred$my_cluster, mean), 
  TACT = tapply(paysred$TACT, paysred$my_cluster, mean), 
  TCHOM = tapply(paysred$TCHOM, paysred$my_cluster, mean))
```
On calcule les rapports de corrélation. On constate que toutes les variables diffèrent suffisamment selon les groupes. Les deux plus importantes sont `EVH` et `TEMP`
```{r include=params$solution}
#Calcul des rapports par variable
summary(lm(EVH ~ my_cluster, data = paysred))$r.squared #eta2=0.82
summary(lm(EVF ~ my_cluster, data = paysred))$r.squared #eta2=0.70
summary(lm(TEMP ~ my_cluster, data = paysred))$r.squared #eta2=0.73
summary(lm(TINF ~ my_cluster, data = paysred))$r.squared #eta2=0.50
summary(lm(TACT ~ my_cluster, data = paysred))$r.squared #eta2=0.71
summary(lm(TCHOM ~ my_cluster, data = paysred))$r.squared #eta2=0.66
```
On représente le nuage de points des deux variables `EVH` et `TEMP` avec les différents clusters :
```{r include=params$solution, fig.width = 6, fig.height = 3.5}
my_col <- c("magenta", "cyan", "orange", "green")
par(las = 1,  mar = c(3, 3, 0.75, 0.5), mgp = c(2., 1, 0))
plot(paysred$EVH, paysred$TEMP, main = "", xlab = "EVH", ylab = "TEMP",
     col = my_col[paysred$my_cluster], pch = 16)
text(paysred$EVH, paysred$TEMP, row.names(paysred), cex = 0.4, pos = 3)
points(my_mean$EVH, my_mean$TEMP, col = my_col, pch = 3)
legend("topleft", legend = paste0("G", 1:4), pch = 16,
       col = c("magenta", "cyan", "orange", "green"))
```
`r if (!params$solution) ":::"` 
:::



## Question

Définir une typologie des pays en prenant les précautions nécessaires. Pour cela, on pourra d'abord utiliser les informations trouvées précédemment. Dans un second temps, on pourra représenter les observations sur les deux premières composantes principales de l'ACP. Pour cela, il faudra interpréter les résultats de l'ACP. 



::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
Description des groupes à partir de la section précédente:

* G1 (11 pays) : `EVH` élevé, `EVF` élevé, `TEMP` élevé, `TINF` faible, `TACT` élevé, `TCHOM` faible
* G2 (7 pays) : `EVH` élevé, `EVF` élevé, `TEMP` faible, `TINF` moyen, `TACT` faible, `TCHOM` moyen
* G3 (5 pays) : `EVH` faible, `EVF` moyen,  `TEMP` moyen, `TINF` faible, `TACT` faible, `TCHOM` élevé 
* G4 (2 pays) : `EVH` faible, `EVF` moyen, `TEMP` faible, `TINF` élevé, `TACT` faible, `TCHOM` faible 

L'ACP va permettre de prendre en compte la structure de corrélation des variables. On fait l'ACP : 
```{r include=params$solution}
library(FactoMineR)
resuacp <- PCA(paysred[, -7], graph = F)
resuacp$eig
resuacp$var$cor
```
On garde 3 axes :

* l'axe 1 est corrélé linéairement >0 avec `EVH`, `TACT` et négativement à `TCHOM`. 
* l'axe 2 corrélé linéairement >0 avec `EVF` et négativement avec `TEMP`
* l'axe 3 est corrélée linéairement >0 avec `TINF`

On représente les groupes sur les premières composantes principales de l'ACP :

```{r include=params$solution, fig.width = 7, fig.height = 3}
my_col <- c("magenta", "cyan", "orange", "green")
par(las = 1,  mar = c(3, 3, 0.75, 0.5), mgp = c(2., 1, 0), 
    mfrow = c(1, 2))
plot(resuacp$ind$coord[, 1], resuacp$ind$coord[, 2], main = "", 
     xlab = "PCA 1", ylab = "PCA 2",
     col = my_col[paysred$my_cluster], pch = 16)
text(resuacp$ind$coord[, 1], resuacp$ind$coord[, 2], 
     row.names(paysred), cex = 0.4, pos = 3)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
plot(resuacp$ind$coord[, 1], resuacp$ind$coord[, 3], main = "", 
     xlab = "PCA 1", ylab = "PCA 3",
     col = my_col[paysred$my_cluster], pch = 16)
text(resuacp$ind$coord[, 1], resuacp$ind$coord[, 3], 
     row.names(paysred), cex = 0.4, pos = 3)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
legend("topright", legend = paste0("G", 1:4), pch = 16,
       col = c("magenta", "cyan", "orange", "green"))
```

* Le groupe 1 contient des pays qui sont fortement corrélés à l'axe 1, i.e. qui ont des valeurs fortes de  `EVH`, `TACT` et faibles de `TCHOM`. Il est opposé au Groupe 3 sur l'axe 1 qui contient lui des pays avec des valeurs faibles de `EVH`, `TACT` et fortes de `TCHOM`
* Le groupe 2 a des valeurs fortes positives sur l'axe 2, i.e. il contient des pays avec des valeurs fortes de `EVF` et faibles de `TEMP`
* Le groupe 4 est influencé par l'axe 3, i.e. qu'il contient des pays avec des valeurs fortes de `TINF`

`r if (!params$solution) ":::"` 
:::




## Question

On réalise ensuite une classification ascendante hiérarchique (CAH) sur ces mêmes données. On calculera dans un premier temps la matrice des distances entre individus sur les données centrées et réduites, avec la fonction `dist()`. Dans un second temps, on utilisera la fonction `hclust()` du package **cluster**. Combien de groupes décidez-vous de choisir pour cette CAH ? Justifier votre réponse.

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
On pourra utiliser le graphique des hauteurs et le dendrogramme (voir notes de cours). 
:::


::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On calcule la matrice de distance et on fait une CAH : 
```{r include=params$solution}
mat_dist <- dist(scale(paysred[, -7]))
resuCAHpays <- hclust(mat_dist, method="ward.D2")
```
On calcule le graphique des hauteurs et le dendrogramme. On choisit 4 classes, même si 3 peuvent suffire.
```{r include=params$solution, fig.width = 8, fig.height = 4.5}
nbcluster <- 24:1
par(mfrow = c(1, 2))
plot(resuCAHpays)
plot(nbcluster, resuCAHpays$height)
```
`r if (!params$solution) ":::"` 
:::



## Question
Comparer le résultat de cette classification avec les classes obtenues par la méthode des $K$-means. 

::: {.callout-caution icon=false collapse=false, .content-visible when-profile="exercise"}
#### Conseils
On pourra utiliser la fonction `cutree()` pour récupérer les classes de la CAH et la fonction `table()` pour comparer les résultats des deux classifications.
:::


::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On récupère les classes de la CAH et on regarde les effectifs 
```{r include=params$solution}
paysred$my_cluster_2 <- factor(cutree(resuCAHpays, k = 4))
table(paysred$my_cluster_2)
```
On constate que le plus gros cluster a 13 observations, il y a deux groupes avec 5 observations et 1 groupe avec 2 observations. On représente les groupes sur les premières composantes principales de l'ACP :
```{r include=params$solution, fig.width = 7, fig.height = 3}
my_col <- c("magenta", "cyan", "orange", "green")
par(las = 1,  mar = c(3, 3, 0.75, 0.5), mgp = c(2., 1, 0), 
    mfrow = c(1, 2))
plot(resuacp$ind$coord[, 1], resuacp$ind$coord[, 2], main = "", 
     xlab = "PCA 1", ylab = "PCA 2",
     col = my_col[paysred$my_cluster_2], pch = 16)
text(resuacp$ind$coord[, 1], resuacp$ind$coord[, 2], 
     row.names(paysred), cex = 0.4, pos = 3)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
plot(resuacp$ind$coord[, 1], resuacp$ind$coord[, 3], main = "", 
     xlab = "PCA 1", ylab = "PCA 3",
     col = my_col[paysred$my_cluster_2], pch = 16)
text(resuacp$ind$coord[, 1], resuacp$ind$coord[, 3], 
     row.names(paysred), cex = 0.4, pos = 3)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
legend("topright", legend = paste0("G", 1:4), pch = 16,
       col = c("magenta", "cyan", "orange", "green"))
```

Si on compare les clusters des $k$-means et de la CAH, on remarque que les clusters correspondent (excepté le numéro qui change) et hormis pour 2 observations qui n'ont pas été affectées dans les mêmes classes. Il s'agit de la France et du Luxembourg. En effet, on remarque que les coordonnées de ces deux pays dans les trois premières composantes principales se situent entre les classes 1 et 2, ce qui explique pourquoi une classification les affecte dans une classe alors qu'une autre méthode les affecte dans une autre classe. L'interprétation des classes est la même, vu que les groupes sont composés quasimment des mêmes observations. 
```{r include=params$solution}
table(paysred$my_cluster, paysred$my_cluster_2)
```
`r if (!params$solution) ":::"` 
:::


## Question
Réaliser la CAH sur les composantes principales données par l'ACP. Commenter.


::: {.callout-tip icon=false collapse=false, .content-hidden when-profile="solution"}
### Solution
`r if (!params$solution) ":::  {.content-hidden}"` 
On calcule la matrice de distance sur les composantes principales et on fait la CAH :
```{r include=params$solution}
my_dist_acp <- dist(resuacp$ind$coord[, 1:3])
resuCAH_acp <- hclust(my_dist_acp, method="ward.D2")
```
On calcule le graphique des hauteurs et le dendrogramme. On choisit 4 classes.
```{r include=params$solution, fig.width = 8, fig.height = 4.5}
nbcluster <- 24:1
par(mfrow = c(1, 2))
plot(resuCAH_acp)
plot(nbcluster, resuCAH_acp$height)
```
On récupère les classes de la CAH et on regarde les effectifs 
```{r include=params$solution}
paysred$my_cluster_3 <- factor(cutree(resuCAH_acp, k = 4))
table(paysred$my_cluster_3)
```
On constate que le plus gros cluster a 10 observations, le second en a 8, le troisième 5 et le dernier 2. On représente les groupes sur les premières composantes principales de l'ACP :
```{r include=params$solution, fig.width = 7, fig.height = 3}
my_col <- c("magenta", "cyan", "orange", "green")
par(las = 1,  mar = c(3, 3, 0.75, 0.5), mgp = c(2., 1, 0), 
    mfrow = c(1, 2))
plot(resuacp$ind$coord[, 1], resuacp$ind$coord[, 2], main = "", 
     xlab = "PCA 1", ylab = "PCA 2",
     col = my_col[paysred$my_cluster_3], pch = 16)
text(resuacp$ind$coord[, 1], resuacp$ind$coord[, 2], 
     row.names(paysred), cex = 0.4, pos = 3)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
plot(resuacp$ind$coord[, 1], resuacp$ind$coord[, 3], main = "", 
     xlab = "PCA 1", ylab = "PCA 3",
     col = my_col[paysred$my_cluster_3], pch = 16)
text(resuacp$ind$coord[, 1], resuacp$ind$coord[, 3], 
     row.names(paysred), cex = 0.4, pos = 3)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
legend("topright", legend = paste0("G", 1:4), pch = 16,
       col = c("magenta", "cyan", "orange", "green"))
```

Si on compare les clusters avec celui des $k$-means, on remarque que les clusters correspondent (excepté le numéro qui change). Par ailleurs, on remarque que seule 1  observation est affectée dans deux groupes différents. Il s'agit de l'Allemagne. En effet, les coordonnées de ce pays dans les trois premières composantes sont entre la classe 1 et 2, ce qui explique pourquoi une classification l'affecte dans une classe alors qu'une autre méthode l'affecte dans une autre classe. L'interprétation des classes est la même, vu que les groupes sont composés quasimment des mêmes observations. 
```{r include=params$solution}
table(paysred$my_cluster, paysred$my_cluster_3)
```
`r if (!params$solution) ":::"` 
:::


